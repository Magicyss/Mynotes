# 两个链表的第一个公共节点

题目描述

输入两个链表，找出它们的第一个公共结点。

剑指offer中的原题，题目不难，给出四种解法，逐渐更优。

第一种时间复杂度O(n^2)，最暴力的方法，两个指针，一个放在第一条链上，一个放在第二条，固定第一个，移动第二条进行比较，最简单粗暴，不需要动脑。

第二种，使用两个额外的栈作为辅助空间，因为如果这两个链表有公共节点，那么最终在通过共同节点之后的节点长度、个数都是一样的，所以可以同时出栈，如果两者相同则继续出栈，直到出现第一个不相同的节点，返回上一个相同的节点即可，时间复杂度是O(n)，空间复杂度O(n)。

第三种，同样根据上面一种的方法，根据“在通过共同节点之后的节点长度、个数都是一样的”这条推论，我们可以通过两个指针先遍历完两条链表，并记录下各自的长度，然后让长的那条先走（长-短）步，然后同步开始遍历，这样也可以找到共同的节点。时间复杂度差不多也是O(n)，空间复杂度是O(1)，相比上一个要节省了很大的空间。

第四种，其实看代码容易懂，解释反而文字容易说不明白，直接上代码：

```c++
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        if(pHead1==nullptr&&pHead2==nullptr){
            return nullptr;
        }
        ListNode* n1=pHead1;
        ListNode* n2=pHead2;
        while(n1!=n2){
            n1= n1==nullptr?pHead2:n1->next;
            n2= n2==nullptr?pHead1:n2->next;
        }
        return n1;
    }
};
```



