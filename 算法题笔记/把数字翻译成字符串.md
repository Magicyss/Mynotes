# 把数字翻译成字符串

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

 这题实际上是剑指offer46.

示例 1:

输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"

这题跟跳台阶其实是类似的，但是当时笔试的时候没有做出来。

一开始的思路就是倒着取，如果我最终剩下的数字是两位，那么判断它有没有大于25，大了说明只能拆成两个单独的数字，也就是一种结果，如果可以合并那就是两种。然后我当时没有考虑比如“09”这种情况，然后对于1位的情况那就是一种，也返回1。当时最严重的的一个误区是，如果返回translateNum(num/10)+translateNum(num/100)想着num/10这个数中包含了num/100这个数，岂不是重复了，然后就把自己卡住了，导致思路想不下去。

现在重新想，思路应该是，递归的最终跳出条件就是只剩下一位数字，此时最终就是这一条路了， 不会有其他分支可以走。然后前文提到的在对于100取模之后的数字需要判断是不是小于10或者大于25。

关于递归调用translateNum(num/10)+translateNum(num/100)这里可以这样理解。如果这里的结果属于10-25，那么可以分成两路，也就是走上了岔路，这里每条方法都是跟之前不一样的字符串了，所以就算后半段有重复，但是一开始的字符串已经不一样了， 所以默认结果就是不一样的。

```c++
class Solution {
public:
    int translateNum(int num) {
        if(num<=9) return 1;
        int temp=num % 100;
        if(temp<10||temp>=26){
            return translateNum(num/10);
        }else{
            return translateNum(num/10)+translateNum(num/100);
        }
    }
};
```

