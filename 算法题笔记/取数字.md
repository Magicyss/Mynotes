# 取数字

题目：

```
两个在玩游戏，现在有一个非递减的数字序列，然后依次进行以下步骤：
每个人选择一个当前序列中的数字，把这个数字在序列中第一次出现的位置及其左边的数字全部删除，当某人操作完之后序列为空时则此人获胜。
```

例如：

```
此时的序列是111222，如果第一个人选择2，那么删除之后得到的序列是22。假设两个人都能做出自己处境的最优解，请问最后谁能获得游戏胜利？
```

输入描述：

```
第一行表示的测例数
对于每组数据，第一行一个整数n，n表示序列中数字的个数。
接下来一行n个整数，其中a[i]表示第i个整数。
```

输出描述：
对于每组数据。
如果第一个人能获胜，输出“1”。
如果第二个人获胜，输出“2”。
输入：

```
1
5
2 2 3 3 6
```

输出：

```
1
```

这道题是某次笔试的题，当时没有做出来，后来想出了算法，不过没法验证是否正确，但还是想记录一下。

思路是：第一个人要取到最后一个数字a，那么最后一个数字在最后出现之前如果没有出现过，那就直接取到了。

如果出现了两次，就要考虑出现第一次是不是第一个数字，如果是第一个数字，即a……a，那么无论第一个人怎么取，都会导致第二个人可以直接选a，赢家就是第二个人，所以考虑另一种情况，如果是……a……a，这种时候，第一个人能否赢，就取决于取到第一个人能否迫使第二个人把第一个a取掉，如果能够取掉，那么最后的a就是第一个人的，如果没法迫使第二个人这样做，那么第二个人就赢了。

这里我在当时陷入的一个误区就是，我接下来就在考虑，如果有3个a？4个a？然后就把自己陷进去了，其实这里大可不必这样，这里两个a是个通用情况，这里就开始考虑上面的……a……a中的第一个省略号的部分，为了保证迫使第二个人取到第一个省略号后面那个a，那么第一个人应该取到第一个省略号后面那个第一个a的前一个数字，这样就就能保证a一定会被第二个人取走，这样问题就成了……ba……a，第一个人如何取到b这个数字，这里就跟一开始取到最后一个a一样，如此同理就可以考虑得到最终的结果了。

```c++
#include <iostream>
#include <cstdio>
#include <math.h>
#include <algorithm>
#include <string>

using namespace std;
typedef long long ll;
const double eps = 1e-8;


int main() {
    int n, l, i;
    int lastOne = -1;
    int nums[1000];
    int winner = 1;
    while (scanf("%d", &n) != EOF) {
        while (n--) {
            scanf("%d", &l);
            for (i = 0; i < l; i++) {
                scanf("%d", &nums[i]);
            }
            lastOne = nums[l - 1];
            for (i = l - 2; i >= 0; i--) {
                if (lastOne == nums[i]) {
                    if (i == 0) {
                        winner = 2;
                    } else {
                        lastOne = nums[i - 1];
                        i--;
                    }
                }
            }
            printf("%d\n",winner);
        }
    }
    return 0;
}
```